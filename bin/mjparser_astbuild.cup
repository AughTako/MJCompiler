

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, FOR, STATIC;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUALEQUAL, NOTEQUAL, GREATER, GREATEROREQUAL, LESS, LESSOREQUAL, AND, OR;
terminal EQUAL, INCREMENT, DECREMENT, SEMI, COLON, COMMA, DOT, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE, LAMBDA;
terminal String IDENT, BOOL;
terminal Character CHAR;
terminal Integer NUM;

/* Program and Declarations */

nonterminal Program Program;
nonterminal ProgName ProgName;
nonterminal DeclList DeclList;
nonterminal Decl Decl;
nonterminal ConstDecl ConstDecl;
nonterminal ConstType ConstType;
nonterminal ConstDeclList ConstDeclList;
nonterminal ConstDeclListNN ConstDeclListNN;
nonterminal VarDecl VarDecl;
nonterminal VarType VarType;
nonterminal VarDeclList VarDeclList;
nonterminal VarDeclListNN VarDeclListNN;
nonterminal StaticInitializer StaticInitializer;
nonterminal MethodDecl MethodDecl;
nonterminal MethodList MethodList;
nonterminal MethodName MethodName;
nonterminal Formals Formals;
nonterminal FormalParams FormalParams;
nonterminal FormalList FormalList;
nonterminal FormalListNN FormalListNN;

/* Expressions & Statements */

nonterminal Expr Expr;
nonterminal Statement Statement;
nonterminal StatementList StatementList;
nonterminal Designator Designator;
nonterminal ExprList ExprList;
nonterminal ElseList ElseList;
nonterminal NumConst NumConst;
nonterminal ForEnter ForEnter;
nonterminal ForDesignator ForDesignator;
nonterminal ConditionOptions ConditionOptions;
nonterminal DesignatorSOptions DesignatorSOptions;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal DesignatorStatementOps DesignatorStatementOps;
nonterminal ActualParamsMaybe ActualParamsMaybe;
nonterminal ActualParams ActualParams;
nonterminal ExprComma ExprComma;

/* Misc */

nonterminal Brackets Brackets;
nonterminal TypeList TypeList;
nonterminal Type Type;
nonterminal Constant Constant;
nonterminal IdentList IdentList;
nonterminal AssignOp AssignOp;
nonterminal OrCondition OrCondition;
nonterminal AndCondition AndCondition;
nonterminal AndFactor AndFactor;
nonterminal ConditionFactor ConditionFactor;
nonterminal Condition Condition;
nonterminal RelOp RelOp;
nonterminal MinOpOptions MinOpOptions;
nonterminal AddOpOptions AddOpOptions;
nonterminal Term Term;
nonterminal MulOpFactorOptions MulOpFactorOptions;
nonterminal Factor Factor;
nonterminal MulOp MulOp;
nonterminal AddOp AddOp;
nonterminal ListOrMatrix ListOrMatrix;
nonterminal FuncCall FuncCall;
nonterminal DesignatorRepetition DesignatorRepetition;
nonterminal Label Label;
nonterminal FuncCallMaybe FuncCallMaybe;

/* ========= BEGIN =========*/

Program ::= PROG ProgName:progName DeclList:D1 LBRACE MethodList:M2 RBRACE {: RESULT=new ProgramDerived1(progName, D1, M2); RESULT.setLine(progNameleft); :};
ProgName ::= IDENT:progName {: RESULT=new ProgNameDerived1(progName); RESULT.setLine(progNameleft); :};

/* ========= Declarations =========*/

	DeclList ::= DeclList:D1 Decl:D2 {: RESULT=new DeclListDerived1(D1, D2); RESULT.setLine(D1left); :}
				|
				(NoDeclList) {: RESULT=new NoDeclList(); :} /* NULL */
				;
	Decl ::= ConstDecl:constant {: RESULT=new DeclDerived1(constant); RESULT.setLine(constantleft); :}
				|
				VarDecl:var {: RESULT=new DeclDerived2(var); RESULT.setLine(varleft); :}
				|
				(ErrorSemi) error SEMI:l
				{:parser.report_error("Izvrsen oporavak do ; ",null); :} {: RESULT=new ErrorSemi(); :}
				;
	
	ConstDecl ::= CONST ConstType:type IDENT:name EQUAL Constant:val ConstDeclList:list SEMI {: RESULT=new ConstDeclDerived1(type, name, val, list); RESULT.setLine(typeleft); :};
	ConstType ::= Type:type {: RESULT=new ConstTypeDerived1(type); RESULT.setLine(typeleft); :};
	ConstDeclList ::= ConstDeclList:C1 ConstDeclListNN:C2 {: RESULT=new ConstDeclListDerived1(C1, C2); RESULT.setLine(C1left); :}
					|
					(ErrorComma) error:l
					{:parser.report_error("Izvrsen oporavak do , ",null); :} {: RESULT=new ErrorComma(); :}
					|
					(NoConstDeclList) {: RESULT=new NoConstDeclList(); :} /* null */
					;
	ConstDeclListNN ::= COMMA IDENT:constName EQUAL Constant:value {: RESULT=new ConstDeclListNNDerived1(constName, value); RESULT.setLine(constNameleft); :};
	
	VarDecl ::= VarType:varType IDENT:varName Brackets:brackets VarDeclList:varList {: RESULT=new VarDeclDerived1(varType, varName, brackets, varList); RESULT.setLine(varTypeleft); :};
	VarType ::= Type:type {: RESULT=new VarTypeDerived1(type); RESULT.setLine(typeleft); :};
	VarDeclList ::= VarDeclList:V1 VarDeclListNN:V2 {: RESULT=new VarDeclListDerived1(V1, V2); RESULT.setLine(V1left); :}
					|
					(NoVarDeclList) {: RESULT=new NoVarDeclList(); :} /* null */
					;
	VarDeclListNN ::= COMMA IDENT:varName Brackets:B1 {: RESULT=new VarDeclListNNDerived1(varName, B1); RESULT.setLine(varNameleft); :};
	
	MethodList ::= MethodList:M1 MethodDecl:M2 {: RESULT=new MethodListDerived1(M1, M2); RESULT.setLine(M1left); :}
				|
				(NoMethodList) {: RESULT=new NoMethodList(); :} /* null */
				;
	MethodDecl ::= MethodName:name_type LPAREN FormalList:F1 RPAREN VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new MethodDeclDerived1(name_type, F1, V2, S3); RESULT.setLine(name_typeleft); :};
	MethodName ::= TypeList:T1 IDENT:I2 {: RESULT=new MethodNameDerived1(T1, I2); RESULT.setLine(T1left); :};
	
/* ========= STATEMENTS & EXPR =========*/
	StaticInitializer ::= STATIC LBRACE StatementList:S1 RBRACE {: RESULT=new StaticInitializerDerived1(S1); RESULT.setLine(S1left); :};
	StatementList ::= StatementList:S1 Statement:S2 {: RESULT=new StatementListDerived1(S1, S2); RESULT.setLine(S1left); :}
					|
					(NoStatementList) {: RESULT=new NoStatementList(); :} /* null */
					;
	Formals ::= FormalParams:F1 {: RESULT=new FormalsDerived1(F1); RESULT.setLine(F1left); :}
				 | 
				 (ErrorForms) error:l
				 {:parser.report_error("Izvrsen oporavak do ) ",null); :} {: RESULT=new ErrorForms(); :}
				 |
				 (NoFormalList) {: RESULT=new NoFormalList(); :} /* null */
				 ;				
	FormalParams ::= Type:T1 IDENT:I2 Brackets:B3 FormalList:F4 {: RESULT=new FormalParamsDerived1(T1, I2, B3, F4); RESULT.setLine(T1left); :};
	FormalList ::= FormalList:F1 FormalListNN:F2 {: RESULT=new FormalListDerived1(F1, F2); RESULT.setLine(F1left); :}
				 |
				 (ErrorFormsComma) error:l
				 {:parser.report_error("Izvrsen oporavak do , ",null); :} {: RESULT=new ErrorFormsComma(); :}
				 |
				 (NoFormL) {: RESULT=new NoFormL(); :} /*null*/
				 ;
				 
	FormalListNN ::= COMMA Type:type IDENT:name Brackets:B1 {: RESULT=new FormalListNNDerived1(type, name, B1); RESULT.setLine(typeleft); :};
	
	Statement ::= DesignatorStatement:D1 SEMI {: RESULT=new StatementDerived1(D1); RESULT.setLine(D1left); :}
				|
				IF LPAREN Condition:C1 RPAREN Statement:S2 ElseList:E3 {: RESULT=new StatementDerived2(C1, S2, E3); RESULT.setLine(C1left); :}
				|
				BREAK SEMI {: RESULT=new StatementDerived3(); :}
				|
				CONTINUE SEMI {: RESULT=new StatementDerived4(); :}
				|
				RETURN ExprList:E1 SEMI {: RESULT=new StatementDerived5(E1); RESULT.setLine(E1left); :}
				|
				READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new StatementDerived6(D1); RESULT.setLine(D1left); :}
				|
				PRINT LPAREN Expr:E1 NumConst:N2 RPAREN SEMI {: RESULT=new StatementDerived7(E1, N2); RESULT.setLine(E1left); :}
				|
				ForEnter:F1 SEMI ForDesignator:F2 RPAREN Statement:S3 {: RESULT=new StatementDerived8(F1, F2, S3); RESULT.setLine(F1left); :}
				|
				LBRACE StatementList:S1 RBRACE {: RESULT=new StatementDerived9(S1); RESULT.setLine(S1left); :}
				;
	
	ForEnter ::= FOR LPAREN ForDesignator:F1 SEMI ConditionOptions:C2 {: RESULT=new ForEnterDerived1(F1, C2); RESULT.setLine(F1left); :};
	ForDesignator ::= DesignatorStatement:D1 DesignatorSOptions:D2 {: RESULT=new ForDesignatorDerived1(D1, D2); RESULT.setLine(D1left); :};
	DesignatorStatement ::= Designator:D1 DesignatorStatementOps:D2 {: RESULT=new DesignatorStatementDerived1(D1, D2); RESULT.setLine(D1left); :};
	DesignatorStatementOps ::= AssignOp:A1 Expr:E2 {: RESULT=new DesignatorStatementOpsDerived1(A1, E2); RESULT.setLine(A1left); :}
							|
							LPAREN ActualParamsMaybe:A1 RPAREN {: RESULT=new DesignatorStatementOpsDerived2(A1); RESULT.setLine(A1left); :}
							|
							INCREMENT {: RESULT=new DesignatorStatementOpsDerived3(); :}
							|
							DECREMENT {: RESULT=new DesignatorStatementOpsDerived4(); :}
							;
	ActualParamsMaybe ::= ActualParams:A1 {: RESULT=new ActualParamsMaybeDerived1(A1); RESULT.setLine(A1left); :} | {: RESULT=new ActualParamsMaybeDerived2(); :} /* null */;
	ActualParams ::= ExprComma:E1 {: RESULT=new ActualParamsDerived1(E1); RESULT.setLine(E1left); :};
	ExprComma ::= ExprComma:E1 COMMA Expr:E2 {: RESULT=new ExprCommaDerived1(E1, E2); RESULT.setLine(E1left); :}
				|
				Expr:E1 {: RESULT=new ExprCommaDerived2(E1); RESULT.setLine(E1left); :}
				;
	
/* ========= MISC =========*/				
	
	
	Condition ::= AndCondition:A1 OrCondition:O2 {: RESULT=new ConditionDerived1(A1, O2); RESULT.setLine(A1left); :}
				|
				error:l
				{:parser.report_error("Izvrsen oporavak if naredbe ; ",null); :} {: RESULT=new ConditionDerived2(); :}
				;
	OrCondition ::= OrCondition:O1 OR AndCondition:A2 {: RESULT=new OrConditionDerived1(O1, A2); RESULT.setLine(O1left); :}
				| {: RESULT=new OrConditionDerived2(); :}
				/* null */
				;
	AndCondition ::= ConditionFactor:C1 AndFactor:A2 {: RESULT=new AndConditionDerived1(C1, A2); RESULT.setLine(C1left); :};
	AndFactor ::= AndFactor:A1 AND ConditionFactor:C2 {: RESULT=new AndFactorDerived1(A1, C2); RESULT.setLine(A1left); :}
				| {: RESULT=new AndFactorDerived2(); :}
				/* null */
				; 
	ConditionFactor ::= Expr:exprA RelOp:R1 Expr:exprB {: RESULT=new ConditionFactorDerived1(exprA, R1, exprB); RESULT.setLine(exprAleft); :}
				|
				Expr:E1 {: RESULT=new ConditionFactorDerived2(E1); RESULT.setLine(E1left); :}
				;
				
	IdentList ::= COLON COLON IDENT:I1 {: RESULT=new IdentListDerived1(I1); RESULT.setLine(I1left); :}
				| {: RESULT=new IdentListDerived2(); :}
				/* null */
				;
				
	Brackets ::= LBRACKET RBRACKET {: RESULT=new BracketsDerived1(); :}
				|
				LBRACKET Expr:E1 RBRACKET LBRACKET Expr:E2 RBRACKET {: RESULT=new BracketsDerived2(E1, E2); RESULT.setLine(E1left); :}
				|
				LBRACKET Expr:E1 RBRACKET {: RESULT=new BracketsDerived3(E1); RESULT.setLine(E1left); :}
				| {: RESULT=new BracketsDerived4(); :}
				/* NULL */
				;
				
	Expr ::= MinOpOptions:M1 AddOpOptions:A2 {: RESULT=new ExprDerived1(M1, A2); RESULT.setLine(M1left); :};
	MinOpOptions ::= MINUS {: RESULT=new MinOpOptionsDerived1(); :} | (NoMinOpt) {: RESULT=new NoMinOpt(); :} /* null */;
	AddOpOptions ::= AddOpOptions:A1 AddOp:A2 Term:T3 {: RESULT=new AddOpOptionsDerived1(A1, A2, T3); RESULT.setLine(A1left); :};
	Term ::= MulOpFactorOptions:M1 {: RESULT=new TermDerived1(M1); RESULT.setLine(M1left); :};
	MulOpFactorOptions ::= MulOpFactorOptions:M1 MulOp:M2 Factor:F3 {: RESULT=new MulOpFactorOptionsDerived1(M1, M2, F3); RESULT.setLine(M1left); :}
						|
						Factor:F1 {: RESULT=new MulOpFactorOptionsDerived2(F1); RESULT.setLine(F1left); :};
	Factor ::= FuncCall:F1 {: RESULT=new FactorDerived1(F1); RESULT.setLine(F1left); :} | NUM:N1 {: RESULT=new FactorDerived2(N1); RESULT.setLine(N1left); :} | CHAR:C1 {: RESULT=new FactorDerived3(C1); RESULT.setLine(C1left); :} | BOOL:B1 {: RESULT=new FactorDerived4(B1); RESULT.setLine(B1left); :} | NEW Type:T1 ListOrMatrix:L2 {: RESULT=new FactorDerived5(T1, L2); RESULT.setLine(T1left); :} | LPAREN Expr:E1 RPAREN {: RESULT=new FactorDerived6(E1); RESULT.setLine(E1left); :};
	ListOrMatrix ::= LBRACKET Expr:E1 RBRACKET {: RESULT=new ListOrMatrixDerived1(E1); RESULT.setLine(E1left); :} 
					|
					LBRACKET Expr:E1 RBRACKET LBRACKET Expr:E2 RBRACKET {: RESULT=new ListOrMatrixDerived2(E1, E2); RESULT.setLine(E1left); :}
					;
	FuncCall ::=  Designator:D1 LPAREN ActualParamsMaybe:A2 RPAREN {: RESULT=new FuncCallDerived1(D1, A2); RESULT.setLine(D1left); :} | FuncCallMaybe:F1 {: RESULT=new FuncCallDerived2(F1); RESULT.setLine(F1left); :};
	
	Designator ::= IDENT:I1 LBRACKET IdentList:I2 DesignatorRepetition:D3 RBRACKET {: RESULT=new DesignatorDerived1(I1, I2, D3); RESULT.setLine(I1left); :};
	DesignatorRepetition ::= DesignatorRepetition:D1 DOT IDENT:I2 {: RESULT=new DesignatorRepetitionDerived1(D1, I2); RESULT.setLine(D1left); :}
							|
							DesignatorRepetition:D1 LBRACKET Expr:E2 RBRACKET {: RESULT=new DesignatorRepetitionDerived2(D1, E2); RESULT.setLine(D1left); :}
							| {: RESULT=new DesignatorRepetitionDerived3(); :}
							/* null */
							;

	Label ::= IDENT:I1 {: RESULT=new LabelDerived1(I1); RESULT.setLine(I1left); :};
	
	Constant ::= NUM:N1 {: RESULT=new ConstantDerived1(N1); RESULT.setLine(N1left); :}
				|
				CHAR:C1 {: RESULT=new ConstantDerived2(C1); RESULT.setLine(C1left); :}
				|
				BOOL:B1 {: RESULT=new ConstantDerived3(B1); RESULT.setLine(B1left); :}
				;
	RelOp ::= EQUALEQUAL {: RESULT=new RelOpDerived1(); :}
		|
		NOTEQUAL {: RESULT=new RelOpDerived2(); :}
		|
		GREATER {: RESULT=new RelOpDerived3(); :}
		|
		GREATEROREQUAL {: RESULT=new RelOpDerived4(); :}
		|
		LESS {: RESULT=new RelOpDerived5(); :}
		|
		LESSOREQUAL {: RESULT=new RelOpDerived6(); :}
		;
	MulOp ::= MUL {: RESULT=new MulOpDerived1(); :} | DIV {: RESULT=new MulOpDerived2(); :} | MOD {: RESULT=new MulOpDerived3(); :};
	AddOp ::= PLUS {: RESULT=new AddOpDerived1(); :} | MINUS {: RESULT=new AddOpDerived2(); :};
	Type ::= IDENT:I1 IdentList:I2 {: RESULT=new TypeDerived1(I1, I2); RESULT.setLine(I1left); :};
	AssignOp ::= EQUAL {: RESULT=new AssignOpDerived1(); :};